#!python

"""Aligns and counts mutations in barcoded subamplicons.

Written by Jesse Bloom."""


import sys
import os
import time
import logging
import dms_tools.parsearguments
import dms_tools.file_io
import dms_tools.utils



def main():
    """Main body of script."""

    # Parse command line arguments
    parser = dms_tools.parsearguments.BarcodedSubampliconsParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # some sanity checking on arguments
    for (refseqstart, refseqend, r1trim, r2trim) in args['alignspecs']:
        if args['barcodelength'] >= r1trim:
            raise ValueError("One of the alignspecs specifies R1TRIM of %d, which doesn't fully trim a barcode of barcodelength %d" % (r1trim, args['barcodelength']))
        if args['barcodelength'] >= r2trim:
            raise ValueError("One of the alignspecs specifies R2TRIM of %d, which doesn't fully trim a barcode of barcodelength %d" % (r2trim, args['barcodelength']))

    # set up logging
    logging.shutdown()
    logfile = "%s.log" % args['outprefix']
    if os.path.isfile(logfile):
        os.remove(logfile)
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)
    logger.info("Beginning execution of %s\nProgress will be logged to %s" % (prog, logfile))

    # log in try / except loop
    try:
        logger.info('Beginning execution of %s in directory %s\n' % (prog, os.getcwd()))
        logger.info('Progress is being logged to %s\n' % logfile)
        versionstring = dms_tools.file_io.Versions() 
        logger.info(versionstring)
        logger.info('Parsed the following arguments:\n%s\n' % '\n'.join(['\t%s = %s' % tup for tup in args.iteritems()]))

        # start iterating over the reads in the files
        assert len(args['r1files']) == len(args['r2files']), "r1files and r2files do not specify the same number of files."
        if all([os.path.splitext(f)[1].lower() == '.gz' for f in args['r1files'] + args['r2files']]):
            gzipped = True
        else:
            if any([os.path.splitext(f)[1].lower() == '.gz' for f in args['r1files'] + args['r2files']]):
                raise ValueError("Some but not all of the r1files and r2files are gzipped. Either all or no files can be gzipped.")
            gzipped = False

        # collect reads by barcode
        readcategories = ['total', 'failed Illumina filter', 'low quality']
        n = dict([(category, 0) for category in readcategories])
        barcodes = {}
        logger.info('Now parsing reads from the following:\n\tr1files: %s\n\tr2files: %s' % (' '.join(args['r1files']), ' '.join(args['r2files'])))
        for read_tup in dms_tools.file_io.IteratePairedFASTQ(args['r1files'], args['r2files'], gzipped, applyfilter=True):
            n['total'] += 1
            if read_tup:
                (name, r1, r2, q1, q2) = read_tup
                qcheckedreads = dms_tools.utils.CheckReadQuality(r1, r2, q1, q2, args['minq'], args['maxlowqfrac'], args['barcodelength'])
                if qcheckedreads:
                    (r1, r2) = qcheckedreads
                    barcode = r1[ : args['barcodelength']] + r2[ : args['barcodelength']]
                    if barcode in barcodes:
                        barcodes[barcode]['reads'].append((r1, r2))
                    else:
                        barcodes[barcode] = {'reads':[(r1, r2)]}
                else:
                    n['low quality'] += 1
            else:
                n['failed Illumina filter'] += 1
            if n['total'] % 1e5 == 0:
                logger.info('Reads parsed so far: %d' % n['total'])

        logger.info('Finished parsing all %d reads\n' % n['total'])

        # Examine barcodes to see if they pass criteria
        logger.info('Now examining all %d barcodes to see if reads meet criteria for retention' % len(barcodes))
        newreadcategories = []
        retainedkeystring = 'retained barcode(s) with %d read(s)'
        discardedkeystring = 'discarded barcode(s) with %d read(s)'
        ibarcode = 0
        for barcode in list(barcodes.iterkeys()):
            ibarcode += 1
            if ibarcode % 1e5 == 0:
                logger.info('Barcodes examined so far: %s' % ibarcode)
            nreads = len(barcodes[barcode]['reads'])
            if nreads < args['minreadsperbarcode']:
                barcodes[barcode]['retained'] = False
                barcodes[barcode]['reason'] = 'Too few reads'
            else:
                consensus = dms_tools.utils.BuildReadConsensus(barcodes[barcode]['reads'], args['minreadidentity'], args['minreadconcurrence'], args['maxreadtrim'])
                if consensus:
                    barcodes[barcode]['retained'] = True
                    barcodes[barcode]['consensus'] = consensus
                else:
                    barcodes[barcode]['retained'] = False
                    barcodes[barcode]['reason'] = 'Reads not sufficiently identical'
            keystring = {True:retainedkeystring, False:discardedkeystring}[barcodes[barcode]['retained']] % nreads
            try:
                n[keystring] += 1
            except KeyError:
                n[keystring] = 1
                newreadcategories.append((nreads, keystring))
        newreadcategories.sort()
        readcategories = readcategories + [tup[1] for tup in newreadcategories]
        assert ibarcode == len(barcodes)
        logger.info('Finishing examining all %d barcodes\n' % ibarcode)

        # Summarize statistics
        logger.info('Here are the summary statistics:\n%s' % '\n'.join(['\t%s = %s' % (category, n[category]) for category in readcategories]))

    except:
        logger.exception('Terminating %s at %s with ERROR' % (prog, time.asctime()))
    else:
        logger.info('Successful completion of %s at %s' % (prog, time.asctime()))
    finally:
        logging.shutdown()


if __name__ == '__main__':
    main() # run the script

#!python

"""Subassembles sequences.

Written by Jesse Bloom."""


import sys
import os
import time
import logging
import gzip
import random
import Bio.SeqIO
import dms_tools
import dms_tools.parsearguments
import dms_tools.file_io
import dms_tools.utils



def main():
    """Main body of script."""
    random.seed(1)

    # Parse command line arguments
    parser = dms_tools.parsearguments.SubassembleParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # set up logging
    logging.shutdown()
    logfile = "%s.log" % args['outprefix']
    if os.path.isfile(logfile):
        os.remove(logfile)
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)
    logger.info("Beginning execution of %s in directory %s\n" % (prog, os.getcwd()))
    logger.info("Progress will be logged to %s" % logfile)

    # define file names and delete existing files
    unalignedfilename = "%s_unaligned_R2_reads.txt" % args['outprefix']
    readsperbarcodefilename = "%s_readsperbarcode.txt" % args['outprefix']
    outfilenames = [unalignedfilename, readsperbarcodefilename]
    for f in outfilenames:
        if os.path.isfile(f):
            os.remove(f)
            logger.info("Removing existing file %s" % f)

    # log in try / except loop
    try:
        versionstring = dms_tools.file_io.Versions() 
        logger.info("%s\n" % versionstring)
        logger.info('Parsed the following arguments:\n%s\n' % '\n'.join(['\t%s = %s' % tup for tup in args.iteritems()]))

        # read refseq
        refseq = [seq for seq in Bio.SeqIO.parse(open(args['refseq']), 'fasta')]
        assert len(refseq) == 1, "refseq of %s does not specify exactly one sequence" % args['refseq']
        refseq = str(refseq[0].seq).upper()
        if args['chartype'] == 'codon':
            assert len(refseq) % 3 == 0, "refseq does not specify a sequence of codons since its length of %d nucleotides is not a multiple of 3" % (len(refseq))
            sites = [i + 1 for i in range(len(refseq) // 3)]
            logger.info('Read a reference sequence of %d codons from %s\n' % (len(refseq) // 3, args['refseq']))
        else:
            raise ValueError("Invalid chartype")

        # do some checking on validity of alignspecs
        for (refseqstart, r2start) in args['alignspecs']:
            if r2start < 1:
                raise ValueError("R2START must be >= 1; you specified %d" % r2start)
            if (refseqstart < 0 or refseqstart > len(refseq)):
                raise ValueError("One of the alignspecs specifies REFSEQSTART of %d, which is not valid for a refseq of length %d nucleotides." % (refseqstart, len(refseq)))

        # check on read files
        assert len(args['r1files']) == len(args['r2files']), "r1files and r2files do not specify the same number of files."
        if all([os.path.splitext(f)[1].lower() == '.gz' for f in args['r1files'] + args['r2files']]):
            gzipped = True
        else:
            if any([os.path.splitext(f)[1].lower() == '.gz' for f in args['r1files'] + args['r2files']]):
                raise ValueError("Some but not all of the r1files and r2files are gzipped. Either all or no files can be gzipped.")
            gzipped = False

        # collect 3' trimmed R2 reads by barcode while filtering low quality reads
        readcategories = ['total read pairs', 'read pairs that fail Illumina filter', 'low quality read pairs', 'unalignable read pairs']
        if args['purgefrac']:
            readcategories.append('randomly purged read pairs')
        n = dict([(category, 0) for category in readcategories])
        barcodes = {} # keyed bar barcode, values are lists of 3'-trimmed R2 reads
        logger.info('Now parsing reads from the following:\n\tr1files: %s\n\tr2files: %s' % (' '.join(args['r1files']), ' '.join(args['r2files'])))
        for read_tup in dms_tools.file_io.IteratePairedFASTQ(args['r1files'], args['r2files'], gzipped, applyfilter=True):
            n['total read pairs'] += 1
            if args['purgefrac'] and args['purgefrac'] > random.random():
                n['randomly purged read pairs'] += 1
            elif read_tup:
                (name, r1, r2, q1, q2) = read_tup
                (r1, r2) = dms_tools.utils.CheckReadQuality(r1, r2, q1, q2, args['minq'], 1, 0) # convert low quality to N
                assert len(r1) >= args['barcodelength'], "R1 isn't as long as the required barcodelength"
                barcode = r1[ : args['barcodelength']]
                if args['trimR2']:
                    r2 = r2[ : -args['trimR2']]
                if ('N' in barcode) or (r2.count('N') > args['maxlowqfrac'] * len(r2)):
                    n['low quality read pairs'] += 1
                else:
                    if barcode in barcodes:
                        barcodes[barcode].append(r2)
                    else:
                        barcodes[barcode] = [r2]
            else:
                n['read pairs that fail Illumina filter'] += 1
            if n['total read pairs'] % 1e5 == 0:
                logger.info('Reads parsed so far: %d' % n['total read pairs'])
        logger.info('Finished parsing all %d reads; ended up with %d unique barcodes.\n' % (n['total read pairs'], len(barcodes)))

        # now align reads to subassemble gene
        logger.info('Now subassembling barcodes by aligning reads...')
        if not args['no_write_unaligned']:
            logger.info('Unalignable reads will be written to %s' % unalignedfilename)
            f_unaligned = open(unalignedfilename, 'w')
        nwithalignableread = 0
        for (ibarcode, barcode) in enumerate(list(barcodes.keys())):
            alignedaread = False
            counts = dict([(site, {}) for site in sites])
            if ibarcode % 1e5 == 0:
                logger.info('Have attempted to subassemble %d barcodes; %d have had at least one alignable read.' % (ibarcode, nwithalignableread))
            for read in barcodes[barcode]:
                for (refseqstart, r2start) in args['alignspecs']:
                    if dms_tools.utils.AlignRead(refseq, read[r2start - 1 : ], refseqstart, args['maxmuts'], counts, args['chartype']):
                        if not alignedaread:
                            alignedaread = True
                            nwithalignableread += 1
                        break # aligned, go to next read
                else:
                    n['unalignable read pairs'] += 1
                    if not args['no_write_unaligned']:
                        f_unaligned.write('%s\n' % read)
            del barcodes[barcode] # frees some memory
        if not args['no_write_unaligned']:
            f_unaligned.close()

        sys.exit() # only progressed up to here

        nreads_per_barcode = {}
        for barcode in barcodes:
            nreads = len(barcodes[barcode])
            if nreads in nreads_per_barcode:
                nreads_per_barcode[nreads] += 1
            else:
                nreads_per_barcode[nreads] = 1
        nreadslist = [i for i in range(1, max(nreads_per_barcode.keys()) + 1)]
        for nreads in nreadslist:
            if nreads not in nreads_per_barcode:
                nreads_per_barcode[nreads] = 0
        logger.info('Here are the number of barcodes with each number of reads (also writing this information to %s):\n\tnreads\tnbarcodes\n\t%s\n' % (readsperbarcodefilename, '\n\t'.join(['%d\t%d' % tup for tup in nreads_per_barcode.items()])))
        with open(readsperbarcodefilename, 'w') as f:
            f.write('nreads\tnbarcodes\n%s' % '\n'.join(['%d\t%d' % tup for tup in nreads_per_barcode.items()]))



        # Examine barcodes to see if they pass criteria, if so align them and record mutation counts
        # Set up *counts* as dict that will hold mutation counts in format for dms_tools.file_io.WriteDMSCounts
        counts = {}
        if args['chartype'] == 'codon':
            for r in range(1, len(refseq) // 3 + 1):
                counts[str(r)] = dict([('WT', refseq[3 * r - 3 : 3 * r])] + [(codon, 0) for codon in dms_tools.codons])
        else:
            raise ValueError("Invalid chartype %s" % args['chartype'])
        # Now start looping over barcodes
        logger.info('Now examining the %d barcodes to see if reads meet criteria for retention' % len(barcodes))
        newreadcategories = []
        unalignedkeystring = 'un-alignable barcodes with %d reads'
        alignedkeystring = 'aligned barcodes with %d reads'
        discardedkeystring = 'discarded barcodes with %d reads'
        ibarcode = 0
        for barcode in list(barcodes.iterkeys()):
            if ibarcode % 1e5 == 0:
                logger.info('Barcodes examined so far: %s' % ibarcode)
            nreads = len(barcodes[barcode])
            if nreads < args['minreadsperbarcode']:
                if args['barcodeinfo']:
                    barcodeinfofile.write('BARCODE: %s\nRETAINED: no\nDESCRIPTION: too few reads\nCONSENSUS: none\nREADS:\n\t%s\n\n' % (barcode, '\n\t'.join(['R1 = %s; R2 = %s' % tup for tup in barcodes[barcode]])))
                keystring = discardedkeystring % nreads
            else:
                consensus = dms_tools.utils.BuildReadConsensus(barcodes[barcode], args['minreadidentity'], args['minreadconcurrence'], args['maxreadtrim'], use_cutils=True)
                if consensus:
                    # try to align subamplicon
                    (r1, r2) = consensus
                    for (refseqstart, refseqend, r1start, r2start) in args['alignspecs']:
                        maxN = int(args['maxlowqfrac'] * min(refseqend - refseqstart + 1, len(r1) + len(r2) - r1start - r2start + 2))
                        if r1start >= len(r1) or r2start >= len(r2):
                            aligned = False # reads too short toa align
                        elif not args['R1_is_antisense']:
                            aligned = dms_tools.utils.AlignSubamplicon(refseq, r1[r1start - 1 : ], r2[r2start - 1 : ], refseqstart, refseqend, args['maxmuts'], maxN, args['chartype'], counts, use_cutils=True)
                        else:
                            aligned = dms_tools.utils.AlignSubamplicon(refseq, r2[r2start - 1 : ], r1[r1start - 1 : ], refseqstart, refseqend, args['maxmuts'], maxN, args['chartype'], counts, use_cutils=True)
                        if aligned:
                            keystring = alignedkeystring % nreads
                            if args['barcodeinfo']:
                                barcodeinfofile.write('BARCODE: %s\nRETAINED: yes\nDESCRIPTION: aligned from %d to %d with %d %s mutations\nCONSENSUS: R1 = %s; R2 = %s\nREADS:\n\t%s\n\n' % (barcode, refseqstart, refseqend, aligned[1], args['chartype'], r1, r2, '\n\t'.join(['R1 = %s; R2 = %s' % tup for tup in barcodes[barcode]])))
                            break
                    else:
                        keystring = unalignedkeystring % nreads
                        if args['barcodeinfo']:
                            barcodeinfofile.write('BARCODE: %s\nRETAINED: no\nDESCRIPTION: subamplicon could not be aligned to refseq\nCONSENSUS: R1 = %s; R2 = %s\nREADS:\n\t%s\n\n' % (barcode, r1, r2, '\n\t'.join(['R1 = %s; R2 = %s' % tup for tup in barcodes[barcode]])))
                else:
                    if args['barcodeinfo']:
                        barcodeinfofile.write('BARCODE: %s\nRETAINED: no\nDESCRIPTION: reads not sufficiently identical\nCONSENSUS: none\nREADS:\n\t%s\n\n' % (barcode, '\n\t'.join(['R1 = %s; R2 = %s' % tup for tup in barcodes[barcode]])))
                    keystring = discardedkeystring % nreads
            try:
                n[keystring] += 1
            except KeyError:
                n[keystring] = 1
                newreadcategories.append((nreads, keystring))
            del barcodes[barcode] # free up memory as we finish with barcodes
        newreadcategories.sort()
        readcategories = readcategories + [tup[1] for tup in newreadcategories]
        logger.info('Finished examining all %d barcodes\n' % ibarcode)

        # Write the counts
        logger.info('Writing the %s counts to %s' % (args['chartype'], countsfilename))
        dms_tools.file_io.WriteDMSCounts(countsfile, counts)

        # Summarize statistics
        logger.info('Here are the summary statistics (these are also being written to %s):\n%s' % (summarystatsfilename, '\n'.join(['\t%s = %s' % (category, n[category]) for category in readcategories])))
        summarystatsfile.write('\n'.join(['%s = %s' % (category, n[category]) for category in readcategories]))

    except:
        logger.exception('Terminating %s at %s with ERROR' % (prog, time.asctime()))
        for f in outfilenames:
            if os.path.isfile(f):
                os.remove(f)
                logger.exception('Deleting file %s' % f)
        raise
    else:
        logger.info('Successful completion of %s at %s' % (prog, time.asctime()))
    finally:
        logging.shutdown()


if __name__ == '__main__':
    main() # run the script

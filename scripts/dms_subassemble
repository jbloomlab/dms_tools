#!python

"""Subassembles sequences.

Written by Jesse Bloom."""


import sys
import os
import time
import logging
import gzip
import random
import Bio.SeqIO
import dms_tools
import dms_tools.parsearguments
import dms_tools.file_io
import dms_tools.utils



def main():
    """Main body of script."""
    random.seed(1)

    # Parse command line arguments
    parser = dms_tools.parsearguments.SubassembleParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # set up logging
    logging.shutdown()
    logfile = "%s.log" % args['outprefix']
    if os.path.isfile(logfile):
        os.remove(logfile)
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)
    logger.info("Beginning execution of %s in directory %s\n" % (prog, os.getcwd()))
    logger.info("Progress will be logged to %s" % logfile)

    # define file names and delete existing files
    unalignedfilename = "%s_unaligned_R2_reads.txt" % args['outprefix']
    readsperbarcodefilename = "%s_alignablereadsperbarcode.txt" % args['outprefix']
    refseqstartsfilename = '%s_refseqstarts.txt' % args['outprefix']
    outfilenames = [unalignedfilename, readsperbarcodefilename]
    for f in outfilenames:
        if os.path.isfile(f):
            os.remove(f)
            logger.info("Removing existing file %s" % f)

    # log in try / except loop
    try:
        versionstring = dms_tools.file_io.Versions() 
        logger.info("%s\n" % versionstring)
        logger.info('Parsed the following arguments:\n%s\n' % '\n'.join(['\t%s = %s' % tup for tup in args.iteritems()]))

        # read refseq
        refseq = [seq for seq in Bio.SeqIO.parse(open(args['refseq']), 'fasta')]
        assert len(refseq) == 1, "refseq of %s does not specify exactly one sequence" % args['refseq']
        refseq = str(refseq[0].seq).upper()
        if args['chartype'] == 'codon':
            assert len(refseq) % 3 == 0, "refseq does not specify a sequence of codons since its length of %d nucleotides is not a multiple of 3" % (len(refseq))
            sites = [i + 1 for i in range(len(refseq) // 3)]
            logger.info('Read a reference sequence of %d codons from %s\n' % (len(refseq) // 3, args['refseq']))
        else:
            raise ValueError("Invalid chartype")

        # do some checking on validity of alignspecs
        for (refseqstart, r2start) in args['alignspecs']:
            if r2start < 1:
                raise ValueError("R2START must be >= 1; you specified %d" % r2start)
            if (refseqstart < 0 or refseqstart > len(refseq)):
                raise ValueError("One of the alignspecs specifies REFSEQSTART of %d, which is not valid for a refseq of length %d nucleotides." % (refseqstart, len(refseq)))

        # check on read files
        assert len(args['r1files']) == len(args['r2files']), "r1files and r2files do not specify the same number of files."
        if all([os.path.splitext(f)[1].lower() == '.gz' for f in args['r1files'] + args['r2files']]):
            gzipped = True
        else:
            if any([os.path.splitext(f)[1].lower() == '.gz' for f in args['r1files'] + args['r2files']]):
                raise ValueError("Some but not all of the r1files and r2files are gzipped. Either all or no files can be gzipped.")
            gzipped = False

        # collect 3' trimmed R2 reads by barcode while filtering low quality reads
        readcategories = ['total read pairs', 'read pairs that fail Illumina filter', 'low quality read pairs', 'unalignable read pairs']
        if args['purgefrac']:
            readcategories.append('randomly purged read pairs')
        n = dict([(category, 0) for category in readcategories])
        barcodes = {} # keyed bar barcode, values are lists of 3'-trimmed R2 reads
        logger.info('Now parsing reads from the following:\n\tr1files: %s\n\tr2files: %s' % (' '.join(args['r1files']), ' '.join(args['r2files'])))
        for read_tup in dms_tools.file_io.IteratePairedFASTQ(args['r1files'], args['r2files'], gzipped, applyfilter=True):
            n['total read pairs'] += 1
            if args['purgefrac'] and args['purgefrac'] > random.random():
                n['randomly purged read pairs'] += 1
            elif read_tup:
                (name, r1, r2, q1, q2) = read_tup
                (r1, r2) = dms_tools.utils.CheckReadQuality(r1, r2, q1, q2, args['minq'], 1, 0) # convert low quality to N
                assert len(r1) >= args['barcodelength'], "R1 isn't as long as the required barcodelength"
                barcode = r1[ : args['barcodelength']]
                if args['trimR2']:
                    r2 = r2[ : -args['trimR2']]
                if ('N' in barcode) or (r2.count('N') > args['maxlowqfrac'] * len(r2)):
                    n['low quality read pairs'] += 1
                else:
                    if barcode in barcodes:
                        barcodes[barcode].append(r2)
                    else:
                        barcodes[barcode] = [r2]
            else:
                n['read pairs that fail Illumina filter'] += 1
            if n['total read pairs'] % 1e5 == 0:
                logger.info('Reads parsed so far: %d' % n['total read pairs'])
        logger.info('Finished parsing all %d reads; ended up with %d unique barcodes that passed the quality filters.\n' % (n['total read pairs'], len(barcodes)))

        # now align reads to subassemble gene
        logger.info('Now subassembling barcodes by aligning reads...')
        if not args['no_write_unaligned']:
            logger.info('Unalignable reads will be written to %s' % unalignedfilename)
            f_unaligned = open(unalignedfilename, 'w')
        nwithalignableread = 0 # number of barcodes with at least one alignable reads
        nreads_per_barcode = {}
        refseqstarts = dict([(refseqstart, 0) for (refseqstart, r2start) in args['alignspecs']])
        for (ibarcode, barcode) in enumerate(list(barcodes.keys())):
            nalignedreads = 0 # number of alignable reads for this barcode
            counts = dict([(site, {}) for site in sites])
            if ibarcode % 1e5 == 0:
                logger.info('Have attempted to subassemble %d barcodes; %d have had at least one alignable read.' % (ibarcode, nwithalignableread))
            for read in barcodes[barcode]:
                for (refseqstart, r2start) in args['alignspecs']:
                    if dms_tools.utils.AlignRead(refseq, read[r2start - 1 : ], refseqstart, args['maxmuts'], counts, args['chartype']):
                        if not nalignedreads:
                            nwithalignableread += 1
                        nalignedreads += 1
                        refseqstarts[refseqstart] += 1
                        break # aligned, go to next read
                else:
                    n['unalignable read pairs'] += 1
                    if not args['no_write_unaligned']:
                        f_unaligned.write('%s\n' % read)
            if nalignedreads:
                try:
                    nreads_per_barcode[nalignedreads] += 1
                except KeyError:
                    nreads_per_barcode[nalignedreads] = 1
            del barcodes[barcode] # frees some memory
        logger.info('Overall, found at least %d barcodes with at least one alignable read.\n' % nwithalignableread)
        if not args['no_write_unaligned']:
            f_unaligned.close()
        nreads_per_barcode_keys = nreads_per_barcode.keys()
        nreads_per_barcode_keys.sort()
        logger.info('Here are the number of barcodes with each number of alignable reads (also writing to %s):\n\tnreads\tnbarcodes\n\t%s\n' % (readsperbarcodefilename, '\n\t'.join(['%d\t%d' % (i, nreads_per_barcode[i]) for i in nreads_per_barcode_keys])))
        with open(readsperbarcodefilename, 'w') as f:
            f.write('nreads\tnbarcodes\n%s' % '\n'.join(['%d\t%d' % (i, nreads_per_barcode[i]) for i in nreads_per_barcode_keys]))
        logger.info('Here are the distribution of positions where alignable reads began (also writing to %s):\n\trefseqstart\tnreads\n\t%s\n' % (refseqstartsfilename, '\n\t'.join(['%d\t%d' % (refseqstart, refseqstarts[refseqstart]) for (refseqstart, r2start) in args['alignspecs']])))
        with open(refseqstartsfilename, 'w') as f:
            f.write('refseqstart\tnreads\n%s' % '\n'.join(['%d\t%d' % (refseqstart, refseqstarts[refseqstart]) for (refseqstart, r2start) in args['alignspecs']]))

    except:
        logger.exception('Terminating %s at %s with ERROR' % (prog, time.asctime()))
        for f in outfilenames:
            if os.path.isfile(f):
                os.remove(f)
                logger.exception('Deleting file %s' % f)
        raise
    else:
        logger.info('Successful completion of %s at %s' % (prog, time.asctime()))
    finally:
        logging.shutdown()


if __name__ == '__main__':
    main() # run the script

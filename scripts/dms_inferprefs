#!python

"""Infers site-specific character preferences.

Written by Jesse Bloom."""


import sys
import os
import logging
import dms_tools.utils
import dms_tools.parsearguments
import dms_tools.file_io
import dms_tools.mcmc


def main():
    """Main body of script."""

    # Parse command line arguments
    parser = dms_tools.parsearguments.InferPrefsParser()
    args = vars(parser.parse_args())
    if args['logfile'] == 'Base name of "outfile" with extension ".log"':
        args['logfile'] = "%s.log" % os.path.splitext(args['outfile'])[0]
        if os.path.isfile(args['logfile']):
            os.remove(args['logfile'])
    prog = parser.prog

    # Set up to log everything to logfile.
    # Confusingly, pystan defines its own logger which I have NOT been able to silence.
    # So even though the logger set up in this script will only log to logfile, the
    # pystan one imported by both dms_tools.mcmc and the call to dms_tools.file_io.Versions()
    # will log to standard outpout. This is very confusing, but I have not been able to find
    # a better solution until I determine how to silence the pystan logger.
    versionstring = dms_tools.file_io.Versions() 
    logging.shutdown()
    logger = logging.getLogger(prog)
    logger.setLevel(logging.INFO)
    logfile_handler = logging.FileHandler(args['logfile'])
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    # begin execution
    try:
        logger.info('Beginning execution of %s.' % prog)
        logger.info('Progress is being logged to %s' % args['logfile'])
        logger.info(versionstring)
        logger.info('Parsed the following arguments:\n%s' % '\n'.join(['\t%s = %s' % tup for tup in args.iteritems()]))

        # read in the counts
        if args['chartype'].lower() == 'codon_to_aa':
            chartype = 'codon'
            transform_to_aa = True
            characters = dms_tools.codons
            if args['includestop']:
                aas = dms_tools.aminoacids_withstop
            else:
                aas = dms_tools.aminoacids_nostop
        elif args['chartype'].lower() == 'codon':
            chartype = 'codons'
            transform_to_aa = False
            characters = dms_tools.codons
        elif args['chartype'].upper() == 'DNA':
            chartype = 'DNA'
            transform_to_aa = False
            characters = dms_tools.nts
        else:
            raise ValueError("Invalid chartype of %s" % args['chartype'])
        counts_files = {'nrpre':args['n_pre'], 'nrpost':args['n_post']}
        if args['errpre'].lower() == args['errpost'].lower() == 'none':
            error_model = 'none'
        elif args['errpre'] == args['errpost']:
            error_model = 'same'
            counts_files['nrerr'] = args['errpre']
        elif args['errpre'].lower() == 'none' or args['errpost'].lower() == 'none':
            raise ValueError("Either --errpre and --errpost must both be 'none', or they must both NOT be 'none'")
        else:
            error_model = 'different'
            counts_files['nrerrpre'] = args['errpre']
            counts_files['nrerrpost'] = args['errpost']
        (sites, wts, counts) = dms_tools.file_io.ReadMultipleDMSCountsFiles(counts_files.values(), chartype)
        logger.info('There are counts for %d sites, which are:\n%s' % (len(sites), '\n'.join(['\t%s (wildtype identity of %s)' % (r, wts[r]) for r in sites])))
        counts = dict([(name, counts[counts_files[name]]) for name in counts_files.iterkeys()]) # make names count type rather than file

        # set up priors
        if error_model == 'none':
            avgmu = sum([dms_tools.utils.AvgMutRate(counts['nrpre'], chartype)[m] for m in range(1, len(characters[0]) + 1)]) 
            logger.info('Average per-site mutation rate: %g' % avgmu)
        elif error_model == 'same':
            avgepsilon = dms_tools.utils.AvgMutRate(counts['nrerr'], chartype)
            logger.info('Average per-site error rate: %s' % ', '.join(['%g for characters that require %d nucleotide changes' % (avgepsilon[m], m) for m in range(1, len(characters[0]))]))
            avgmu = sum([dms_tools.utils.AvgMutRate(counts['nrpre'], chartype)[m] for m in range(1, len(characters[0]) + 1)])  - sum([avgepsilon[m] for m in range(1, len(characters[0]) + 1)])
            logger.info('Average per-site mutation rate: %g' % avgmu)
        elif error_model == 'different':
            avgepsilon = dms_tools.utils.AvgMutRate(counts['nrerrpre'], chartype)
            logger.info('Average per-site error rate in pre-selection control: %s' % ', '.join(['%g for characters that require %d nucleotide changes' % (avgepsilon[m], m) for m in range(1, len(characters[0]) + 1)]))
            avgmu = sum([dms_tools.utils.AvgMutRate(counts['nrpre'], chartype)[m] for m in range(1, len(characters[0]) + 1)])  - sum([avgepsilon[m] for m in range(1, len(characters[0]) + 1)])
            logger.info('Average per-site mutation rate: %g' % avgmu)
            avgrho = dms_tools.utils.AvgMutRate(counts['nrerrpost'], chartype)
            logger.info('Average per-site error rate in post-selection control: %s' % ', '.join(['%g for characters that require %d nucleotide changes' % (avgrho[m], m) for m in range(1, len(characters[0]) + 1)]))
        else:
            raise ValueError("Invalid error_model %s" % error_model)
        if avgmu <= 0:
            raise ValueError("Average mutation rate of %g is <= 0. Either there are no mutations or the error control has a higher mutation rate than the pre-selection library. Either one is an irresolvable problem." % avgmu)


    finally:
        logging.shutdown()


if __name__ == '__main__':
    main() # run the script

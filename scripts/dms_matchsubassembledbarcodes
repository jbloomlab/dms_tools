#!python

"""Matches barcodes to subassembled variants, makes count files and plots.

Written by Danny Lawrence and Jesse Bloom."""

import time
import os
import dms_tools.parsearguments
import dms_tools.file_io
import dms_tools.cutils


def reverse_comp(seq, quals):
    """Returns the reverse complement of a DNA sequence and the respective Illumina quality scores

    `seq` is a string-formatted DNA sequence using the alphabet (A, C, G, T, N). 
    `quals` is a string containing the respecitve quality score for each base in the DNA sequence.

    `rc_seq` is the reverse-complemented DNA sequence.
    `rc_quals` is quality scores for the reverse-complemented DNA sequence. 
    """

    assert len(seq) == len(quals), "Sequence length does not match quality scores length."
    rc_dict = {'A':'T', 'T':'A', 'G':'C', 'C':'G', 'N':'N'}
    rc_seq = ""
    rc_quals = ""
    
    rc_list = list(reversed(range(len(seq))))
    for i in rc_list:
        nuc = seq[i].upper()
        rc_seq += rc_dict[nuc]
        rc_quals += quals[i]
    return(rc_seq, rc_quals)


def parse_barcodes(r1files, r2files, minquality, bc_len, r1start, r2end):
    """Reads FASTQ files and returns barcodes passing quality threshold.

    Barcodes discarded if either read fails quality filter, if any site
    in barcode doesn't have read quality >= *minquality* for at least one 
    read, or if reads disagree at any site.

    `r1files` and `r2files` are the file names of FASTQ files, which
    are optionally gzipped. Both files must contain the same number of reads
    in the same order.

    `min_quality` is an integer (0-50) indicating the Phred quality score 
    below which a base call will be ignored. Any reads failing the Illumina
    filter are also ignored.

    `bc_len` is the length of the barcode sequence. 

    `r1start` indicates the nucleotide in R1 at which the barcode starts,
    in 1, 2, ... indexing.

    `r2end` indicates how many nucleotides **before** the end of R2 the
    barcode ends.

    The return variable is the tuple *(bc_list, bc_stats)*:

        * *bc_list* is a list of all barcodes that pass the filters.

        * *bc_stats* is a dictionary with the counts of reads parsed. Keys:

            - *nreads* : total reads in files

            - *nfiltered* : number failed Illumina filter

            - *nlowquality* : number that failed quality filter

            - *nmismatched* : number purged due to mismatch

            - *nretained* : number retained, equals *len(bc_list)*.


    """
    if all(map(lambda f: os.path.splitext(f)[-1] == '.gz', r1files + r2files)):
        gzipped = True
    elif all(map(lambda f: os.path.splitext(f)[-1] == '.fastq', r1files + r2files)):
        gzipped = False
    else:
        raise ValueError("FASTQ files must either all end in '.gz' or all end in '.fastq'. Instead we had:\n%s" '\n'.join(r1files + r2files))
    bc_list = []
    r1start -= 1 # decrement so we can use zero-based indexing
    assert r1start >= 0 and r2end >= 0
    minqchar = chr(minquality + 33) # minimum character for Q-score
    ntot = nfiltered = nlowquality = nmismatched = 0
    for read_tup in dms_tools.file_io.IteratePairedFASTQ(r1files, r2files, gzipped, applyfilter=True):
        ntot += 1
        if not read_tup:
            nfiltered += 1
        else:
            (name, r1, r2, q1, q2) = read_tup
            assert len(r1) >= r1start + bc_len, "R1 read %s too short" % name
            assert len(r2) >= r2end + bc_len, "R2 read %s too short" % name
            r1 = r1[r1start : r1start + bc_len]
            q1 = r1[r1start : r1start + bc_len]
            r2 = r2[-bc_len - r2end : -r2end]
            q2 = r2[-bc_len - r2end : -r2end]
            if any(map(lambda x: x[0] < minqchar and x[1] < minqchar, zip(q1, q2))):
                nlowquality += 1
                continue
            r2 = dms_tools.cutils.ReverseComplement(r2)
            if r1 != r2:
                nmismatched += 1
            else:
                bc_list.append(r1)
    assert ntot == len(bc_list) + nfiltered + nlowquality + nmismatched
    bc_stats = {
            'nreads':ntot,
            'nfiltered':nfiltered,
            'nlowquality':nlowquality,
            'nmismatches':nmismatched,
            'nretained':len(bc_list),
            }
    return (bc_list, bc_stats)


def write_counts_file(bc_list, bc_dict, out_prefix):
    """Writes deep mutational scanning counts file.

    `bc_list` is a list of post-selection barcode sequences parsed from *parse_barcodes*.
    `bc_dict` is the dictionary linking barcode sequences with associated mutations given by *get_variants* 
    """
    char_type = 'codon' #'codon' or 'AA'

    refseq = bc_dict['wt_seq']
    sites = [i + 1 for i in range(len(refseq) // 3)]
    refseq_chars = dict([(site, refseq[3 * site - 3 : 3 * site]) for site in sites])


    # Create list of all possible codons. 
    nts = ['A', 'C', 'G', 'T']
    codons_list = []
    for nt1 in nts:
        for nt2 in nts:
            for nt3 in nts:
                codons_list.append('%s%s%s' % (nt1, nt2, nt3))

    aa_list = [ 'A', 'C', 'D', 'E', 'F', 'G', 'H', 
                'I', 'K', 'L', 'M', 'N', 'P', 'Q', 
                'R', 'S', 'T', 'V', 'W', 'Y', '*',]


    trans_dict = {
        'AAA':'K', 'AAC':'N', 'AAG':'K', 'AAT':'N',
        'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
        'AGA':'R', 'AGC':'S', 'AGG':'R', 'AGT':'S',
        'ATA':'I', 'ATC':'I', 'ATG':'M', 'ATT':'I',
        'CAA':'Q', 'CAC':'H', 'CAG':'Q', 'CAT':'H',
        'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
        'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
        'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',
        'GAA':'E', 'GAC':'D', 'GAG':'E', 'GAT':'D',
        'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
        'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
        'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
        'TAA':'*', 'TAC':'Y', 'TAG':'*', 'TAT':'Y',
        'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
        'TGA':'*', 'TGC':'C', 'TGG':'W', 'TGT':'C',
        'TTA':'L', 'TTC':'F', 'TTG':'L', 'TTT':'F',}

        
    outfile_name = 'mut_counts_%s.txt' % (out_prefix)
    if os.path.isfile(outfile_name):
        os.remove(outfile_name)
    outfile = open(outfile_name, 'w')

    notfound_list = []
    bcs_total = 0
    bcs_found = 0
    bcs_notfound = 0
    mut_dict = {}
    for i in range(1, 355):
        if char_type == 'AA':
            mut_dict[str('%03d') % i] = {
            'A':0, 'C':0, 'D':0, 'E':0, 'F':0,
            'G':0, 'H':0, 'I':0, 'K':0, 'L':0,
            'M':0, 'N':0, 'P':0, 'Q':0, 'R':0,
            'S':0, 'T':0, 'V':0, 'W':0, 'Y':0, 
            '*':0, 'WT':trans_dict[refseq_chars[i]]
            }
            codon_list = aa_list

        elif char_type == 'codon':
            mut_dict[str('%03d') % i] = {
            'AAA':0, 'AAC':0, 'AAG':0, 'AAT':0, 'ACA':0, 'ACC':0, 'ACG':0, 'ACT':0,
            'AGA':0, 'AGC':0, 'AGG':0, 'AGT':0, 'ATA':0, 'ATC':0, 'ATG':0, 'ATT':0,
            'CAA':0, 'CAC':0, 'CAG':0, 'CAT':0, 'CCA':0, 'CCC':0, 'CCG':0, 'CCT':0,
            'CGA':0, 'CGC':0, 'CGG':0, 'CGT':0, 'CTA':0, 'CTC':0, 'CTG':0, 'CTT':0,
            'GAA':0, 'GAC':0, 'GAG':0, 'GAT':0, 'GCA':0, 'GCC':0, 'GCG':0, 'GCT':0,
            'GGA':0, 'GGC':0, 'GGG':0, 'GGT':0, 'GTA':0, 'GTC':0, 'GTG':0, 'GTT':0,
            'TAA':0, 'TAC':0, 'TAG':0, 'TAT':0, 'TCA':0, 'TCC':0, 'TCG':0, 'TCT':0,
            'TGA':0, 'TGC':0, 'TGG':0, 'TGT':0, 'TTA':0, 'TTC':0, 'TTG':0, 'TTT':0,
            "WT":refseq_chars[i]
            }
            codon_list = codons_list

    for barcode in bc_list:
        bcs_total += 1
        if barcode in bc_dict:
            bcs_found += 1
            mutations = bc_dict[barcode]
            for mutation in mutations:
                if mutation != 'no_mutations':
                    pos = str(mutation[3:6])
                    new = mutation[-3:]
                    if char_type == 'AA':
                        new_aa = trans_dict[new]
                        mut_dict[pos][new_aa] += 1
                    elif char_type == 'codon':
                        mut_dict[pos][new] += 1


        elif barcode not in bc_dict:
            bcs_notfound += 1
            notfound_list.append(barcode)


    for position in mut_dict:
        muts_at_site = 0
        for mut in mut_dict[position]:
            if mut != "WT":
                muts_at_site += mut_dict[position][mut]
        n_wt = bcs_found - muts_at_site
        wt_codon = mut_dict[position]['WT']
        mut_dict[position][wt_codon] += n_wt

    pos_list = mut_dict.keys()
    pos_list.sort()
    outfile.write('# POSITION WT %s\n' % ' '.join([str(k) for k in codon_list]))
    for aa_pos in pos_list:
        outfile.write(aa_pos+' '+mut_dict[aa_pos]['WT']+' '+'%s\n' % ' '.join([str(mut_dict[aa_pos][j]) for j in codon_list]))
    print('Wrote mutation counts matrix to %s' % outfile_name)
    outfile.close()


def main():
    """Main body of program."""

    parser = dms_tools.parsearguments.MatchSubassembledBarcodesParser()
    args = vars(parser.parse_args())
    prog = parser.prog
    assert len(args['r1files']) == len(args['r2files']), "Different number of r1files and r2files."

    print("Beginning execution of %s in directory %s\n" % (prog, os.getcwd()))a
    versionstring = dms_tools.file_io.Versions()
    print(versionstring)
    print("Parsed the following arguments:\n%s\n" % '\n'.join(['\t%s = %s' % tup for tup in args.items()])
    print("Starting time is %s" % time.asctime())

    # Get subassembled variants for barcodes
    print("\nReading barcode for subassembled variants from %s" % args['subassembled'])
    (bc_dict, bc_length) = dms_tools.file_io.ReadSubassembledVariants(args['subassembled'])
    print("Read barcodes for %d subassembled variants." % len(bc_dict))
    print("The barcodes are of length %d nucleotides." % bc_length)

    # Get selected barcodes that pass quality filters.
    print("\nNow parsing barcodes...")
    (bc_list, bc_stats) = parse_bc(args['r1files'], args['r2files'], args['min_quality'], bc_length, args['r1start'], args['r2end'])
    print("Completed parsing barcodes.")
    print("Here are the stats on the parsing of barcodes from the read pairs:")
    print("\t%s" % '\t\n'.join(["%s = %d" % tup for tup in bc_stats.items()]))
I AM HERE
    # Write counts_file.
    write_counts_file(barcode_list, barcode_dict, args['outprefix'])


    print('\nSuccessfully completed %s at %s' % (prog, time.asctime()))



if __name__ == '__main__':
    main() #run the script
